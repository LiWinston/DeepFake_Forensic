# Traditional Analysis Performance Configuration
# Add these to application.properties for optimal performance

# Thread pool configuration for traditional analysis
traditional.analysis.thread-pool.core-size=${TRADITIONAL_ANALYSIS_CORE_THREADS:4}
traditional.analysis.thread-pool.max-size=${TRADITIONAL_ANALYSIS_MAX_THREADS:12}
traditional.analysis.thread-pool.queue-capacity=${TRADITIONAL_ANALYSIS_QUEUE_CAPACITY:50}

# I/O operations thread pool
io.operations.thread-pool.core-size=${IO_OPERATIONS_CORE_THREADS:8}
io.operations.thread-pool.max-size=${IO_OPERATIONS_MAX_THREADS:24}
io.operations.thread-pool.queue-capacity=${IO_OPERATIONS_QUEUE_CAPACITY:100}

# Memory management for large image processing
traditional.analysis.max-image-memory-mb=${MAX_IMAGE_MEMORY_MB:512}
traditional.analysis.enable-streaming-for-large-images=${ENABLE_STREAMING_PROCESSING:true}
traditional.analysis.large-image-threshold-mb=${LARGE_IMAGE_THRESHOLD_MB:50}

# Performance monitoring
traditional.analysis.enable-performance-metrics=${ENABLE_PERFORMANCE_METRICS:true}
traditional.analysis.log-execution-times=${LOG_EXECUTION_TIMES:true}

# JVM Optimization Recommendations (add these to JVM arguments):
# Memory allocation:
# -Xms2g -Xmx8g
# -XX:NewRatio=1
# -XX:SurvivorRatio=8

# Garbage Collection (for high throughput):
# -XX:+UseG1GC
# -XX:MaxGCPauseMillis=200
# -XX:G1HeapRegionSize=16m

# Or for low latency (alternative):
# -XX:+UseZGC (Java 11+)
# -XX:+UnlockExperimentalVMOptions

# Performance monitoring:
# -XX:+FlightRecorder
# -XX:+UnlockCommercialFeatures (for older Java versions)

# Native memory tracking:
# -XX:NativeMemoryTracking=detail
